//$Id: objects.txt,v 1.8 2004-05-06 18:26:57 ensonic Exp $ :mode=c:collapseFolds=1:folding=indent:
//==============================================================================

// to find out which types exist do
// grep -o "#define Bt_[A-Z]*_TYPE" src/lib/core/libbtcore/*.h

BtMachine {	// no interface, but base-class
	// public methods
	void bt_machine_mute(BtMachinePtr machine);
}

BtSourceMachine extends BtMachine {
}

BtProcessorMachine extends BtMachine {
}

BtSinkMachine extends BtMachine {
}

BtWire { // was BtConnection
}

BtSong {
	// data
	   gchar* name;
  BtSongInfo* song_info; //buztard/meta
  BtSequence* sequence;  //buzztard/sequence
	 BtSetup* setup;     //buzztard/setup

	// public methods
	BtSongPtr bt_song_new(void)
	BtSongPtr bt_song_new_from_file(gchar *file_name);
       void bt_song_destroy(BtSongPtr song);
			 
	  GstBin* bt_song_get_bin(BtSongPtr song);
	     void bt_song_set_master(BtSongPtr song, BtMachinePtr master);
			 
	 gboolean bt_song_play(BtSongPtr song);
   gboolean bt_song_stop(BtSongPtr song);
}

BtSequence {
	GList *rows;	// row with pattern id per track
}

BtSetup {
	GList *machines;	// each entry points to BtMachine
	GList *wires;			// each entry points to BtWire
}

BtPattern {
	GValue[ticks][params] events;
}

BtTimeLine {
	BtPattern* patterns;
	      ???* event;
}

BtSongIO { // base class (because of factory for import) and virtaul methods
	void bt_song_io_register_all();
	GType bt_song_io_detect(const gchar *);

	// we need default implementations for methods like save, that returns an error,
	// as external plugins might not offer a save method  

	// how does the user select the file-type (and therewith the plugin)?
	// do we just try them, one after the other until one groks the file
	//
	// we need a factory function in the base-class GType bt_song_io_detect(const gchar *)
  // * when it is called for the first time (static GList *modules is NULL)
	//   it calls bt_song_io_register_all() which 
	//   1.) scans plugin-folder
	//   2.) opens each g_modules
	//   3.) gets the address of GType bt_song_io_custom_detect(const gchar *);
	//   4.) stores the g_module handle and the function pointer in a list (uhm, global (static) variable)
	// * afterwards it
	//   first tried bt_song_io_native_detect(const gchar *);
	//   if that is okay return(bt_song_io_native_get_type(void));
	//   if that fails it further
	//   iterates the list and calls GType bt_song_io_XXXX_detect(const gchar *); for each entry
	//   every entry tests if it can handle the file
	//   if yes, it does return(bt_song_io_XXXX_get_type(void));
	//
}

BtSongIONative extends BtSongIO { // loads and saves songs in buzztard xml/zip format
}

BtSongIO<XXXX> extends BtSongIO { // external import export plugins
}

//------------------------------------------------------------------------------


BtSong *mysong=g_object_new(BT_SONG,NULL);
//-- loading in the current version
bt_song_load("~/songs.song.bt");
bt_song_import("~/songs.song.bmx");
//-- loading in the new style
BtSongIO *song_io=g_object_new(bt_song_io_detect(fname),NULL);
bt_song_io_load(song_io,mysong,fname);
//-- for saving we need to iterate over the list to get available types

// creating a new wire between two machines
wire=g_object_new(BT_WIRE,"song",mysong,"src",machine1,"dst",machine2);
// the constructor of Bt_WIRE adds the new instance to mysong->setup->wires
//  -> this is not working as we can't rely upon the construction parameters (src,dst)
wire=g_object_new(BT_WIRE,"song",mysong);
// the constructor remembers the ref to the song
bt_wire_connect(wire,machine1,machine2);
// this methods initializes the wire and adds it to wire->song->setup->wires
// -> it needs to g_assert(wire->song);

