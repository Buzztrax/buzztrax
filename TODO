* run 'make todo' to get a list of todo comments from source

* when releasing do:
  * make check
  * cd po;intltool-update -M
  * make dist


* new tests
  * load songs and lookup the parts
    (e.g. bt_machine_get_pattern_by_id)
  * add test for trigger params
  * for ui tests we should have the main-loop under our control:
    * check g_main_context_set_poll_func()
    * or really *run* the main-loop (not just iterate)
      * for this our tests would be scattered over several signal handlers

* new stats
  * http://www.chris-lott.org/resources/cmetrics/cyclo-2.0.tar.gz
    mcstrip tools.c | cyclo -c | sort -k2 -n

* quality checks
  for file in src/lib/core/*.c; do gtkdoc-depscan -v --book gstreamer-0.10:0.10.8 $file; done
  
* check translation markup
  podebug --rewrite=xxx buzztard.pot aa.po
  LC_ALL=aa ./buzztard-edit
  - this creates a translation with all strings wrapped by 'xxx' (Help -> xxxHelpxxx)
  - it is easy to see what is not marked for translation  

* sparse
  make CC=cgcc


* controller api
  * allow to modify interpolation control sequence inplace (scale time or value range)
    - we need a gst_interpolation_control_foreach(cs, callback, user_data)
    - the callback will be called for each controlpoint and can change the
      timestamp and/or value
    - need a way to do it without exposing GstControlPoint internals
      - void callback(GstClockTime *timestamp, GValue *value, gpointer user_data);
  * or have a BtPatternControlSource
    - then we never need to update the timeline controller
    - the individual instances should be relative lightweight and use a central
      controller for some global state
      - we want to pre-cache the tracks for each machine to speed up finding the
        patterns that apply at a given time


* undo/redo/journaling
  - links
    http://www.buzztard.org/index.php/Undo,_redo
    http://www.buzztard.org/index.php/Song_autosaving
  - we do that on the ui level (also the journalling and the replay of it)
  - singleton journal object
    - each undo/redo capabale object registeres with its name there
    - on replay we can take the prefix og the entry and dispatch
    - on journalling we can probably add the prefix
    - it is a stack of journal entries
  - pending parts that need undo/redo
    - machine view
      - machine/wire parameters
    - wavetable view
    - info view


* CPU load per machine
  - as we alway plug the tee-elements on each machine and each wire starts with
    a queue we could do CPU load per thread
    - sources start their own thread
    - effects and the sink live in the thread of one of the incomming wires
    - build a thread_id<->machine mapping
      - a hackish way would be to run a pad_probe before the machine and
        send a message to the bus with the thread-id<->machine association
      - a better way would be to use gst_message_parse_stream_status
        see src/lib/core/song.c::on_song_request_state()
  - ideally we show it on the machine view
    - extra gnome-canvas-item-rect under machine name?
    - extra dialog from tools menu?
    - enable/disable from the view menu
  - bt-command could have a profile option (for play/encode) and print a summary
    at the end


* Allow disabling level-meters
  - we could iterator over machine, check which levels are activated and
    set the 'message' property true/false
  - this could be api on song/setup
  - the recorder would use it for extra speed
  - on slow platforms we could offer that in the UI (where)
    - the view menu?


* eventually merge machine-rename dialog with machine properties


* improve recording dialogs
  - either integrate the progress bar into the recording settings
    - gray out the dialog or progress-bar area depending on phase
  - or use a notebook with hidden pages
    - switch to 2nd page for rendering


* control machines (no in/out)
  - color=gray
    it is never connected and thus, does not need a desaturated shade
  - scheduling
    - from a property notifies on sink-bin
      - need ts
    - run a GstTask and sync to the clock
      - need to implement tempo iface
      - need to hande seeks (to know direction :/)
  - we can use that for midi-out
    - global params: midi-device (enum)
    - voice params: midi-channel, note, velocity, controller1, control-value1, ... 
  - subclass the control-machines from GstElement
    - no pads (and therefore no _loop() or _chain() function
    - we see them in the registry


* play machines via midi
  - we have machines with one or more note-params
    - sometimes only one is a trigger though
    cd bml/tests/testmachine
    grep -H PT_NOTE *.txt.* | sort | uniq -c | sort -g
  - we have machines with one or more value trigger parames (drum machines)
  - we need to have the idle_loop playing when having keyboard assignments
  - gui workflow:
    - v1: start from the key-controllers
      - a toolbar on the bottom
        - show/hide in the view menu
        - left a combobox to select the device (keyboard, midi, ...)
        - next the piano key graphics
        - next two comboboxes for key assignment and velocity assignment
          - velocity assignment is empty, when selecting machine+key,
            it will show possible velocity targets
          - for drum-machines, we select the parameter with the key and put the
            velecity into the respective parameter
      - mark a key-range, assign to machine/note-param (with key offset)
      - select a key-range, unassign
      - move key-ranges
    - v2: start from pattern column headings
      - have bind/unbind like in machine window
      - define split'ed devices elsewhere
  - how to easily assign a series of key to a series of triggers in one machine
    - have a trigger group  (and assign to white keys only)
    - this would manage both key-number and velocity as we'd only bind a series
      of abs-value-controls (velocity) to the drum-machine triggers
  - how to assign velocity to the machines velocity param
  - the current code in machine.c (_poly_control_) would increment the voice on
    each control event, we would need to set both key and velocity though
    we also need to ensure to set velocity first and then the key
    - only inc the voice-counter on the trigger param?


* text parameters in machines
  * for a:
    * text to speech machine we'd like to have strings in the pattern
    * cmd-out machine we'd like to send a dbus command, run a script etc.
  * like we have a wavetable, we could have a text table
    * a list of text snipped (more than 256!)
    * each snippet has a label and a text block (multiline)
  * in a text to speech machine we can use text-table index (gint 16 bit),
    text offset (gint 16 bit char offset), length (unset, to the end) and
    direction (forward, backward)
  * in a command out machine, we use the text table index (gint 16 bit) and
    ev. script parameters (passed as $1, $2, ...)


* wave table, record entries
  * we can just keep the buffers from fakesink/appsink in a list and consolidate
    on eos
  * need device selection on the source


* one framerate for animations
  * we have a couple of things that we update in intervals:
    * 10fps: main-page-waves.c: preview_update_id=g_timeout_add_full(G_PRIORITY_HIGH,1000/10,on_preview_playback_update,(gpointer)self,NULL);
    * 10fps: main-toolbar.c: playback_update_id=g_timeout_add_full(G_PRIORITY_HIGH,1000/10,on_song_playback_update,(gpointer)song,NULL);
    * 10fps: machine.c: g_object_set(PART_*LEVEL,"interval",(GstClockTime)(0.1*GST_SECOND),...
    * 10fps: signal-analysis-dialog: g_object_set(ANALYZER_*, "interval",(GstClockTime)(0.1*GST_SECOND),...
  * we should have one #define somewhere for the UPDATE_INTERVAL
  * ideally we ensure that the framerate is an integer multiple of it
  * it would be nice to avoid a setting, but for slow machines it might be worth it
    (or for fast machine, people could pick a higher rate)
  * we could use configure and have the define in config.h


* pattern and main-page-patterns still contain bits of duplicated code
  * fixup signals
    * only sequence is using it (search for param-changed")
    * the handlers adds the cells to the damage regions, which is a flat data-
      structure, we need to calculate the offsets or introduce groups to also
      simplify the repair api 
    * instead of bt_sequence_repair_{global,voice,wire}_damage_entry()
      we could use one function if we pass the value_group
      * we don't have the pattern in bt_sequence_repair_damage() yet
  * review the pattern api and check if we should use the groups directly
    (run ./api-cleanup.sh to get a report of where the api is used)
    * sequence:
      * when repairing we still look up patterns
    * main-page-patterns:
      * we do a lot of switch(group->type) { PGT_WIRE,PGT_GLOBAL,PGT_VOICE }


* generate a dependency matrix
  * 'make ctags' creates tags files per directory containing symbol locations
  * 'ctags -x --recurse src tests >xref' creates a single xref table containing
    all symbol locations
  * 'find . -name "*.o" -exec nm --undefined-only {} \; | grep " bt_"'
    creates a list of externally called entries
  
