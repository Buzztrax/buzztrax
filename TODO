* run 'make todo' to get a list of todo comments from source

* when releasing do:
  * make check
  * cd po;intltool-update -M
  * make dist


* new tests
  * load songs and lookup the parts
    (e.g. bt_machine_get_pattern_by_id)
  * add test for trigger params
  * for ui tests we should have the main-loop under our control:
    * check g_main_context_set_poll_func()
    * or really *run* the main-loop (not just iterate)
      * for this our tests would be scattered over several signal handlers
* test infrastructure
  * add a stub song-io saver
  * add a stub processor machine
  * add a test application to be able to make the application abstract 
* review tests
  * ensure we follow Arrange/Act/assert or Given/When/Then style
    http://en.wikipedia.org/wiki/Behavior_Driven_Development
  * check that each class is covered by test suites
    lib/core/
      (cd src/lib/core; ls -1 *.c) | grep -v "marshal" >/tmp/c1.txt;
      (cd tests/lib/core; ls -1 s-*.c | cut -c3-) >/tmp/c2.txt;
    lib/ic
      (cd src/lib/ic; ls -1 *.c) | grep -v "marshal" >/tmp/c1.txt;
      (cd tests/lib/ic; ls -1 s-*.c | cut -c3-) >/tmp/c2.txt;
    ui/cmd
      (cd src/ui/cmd; ls -1 *.c) | grep -v "marshal" >/tmp/c1.txt;
      (cd tests/ui/cmd; ls -1 s-*.c | cut -c3-) >/tmp/c2.txt;
    ui/edit
      (cd src/ui/edit; ls -1 *.c) | grep -v "marshal" >/tmp/c1.txt;
      (cd tests/ui/edit; ls -1 s-*.c | cut -c3-) >/tmp/c2.txt;
    *
      comm -2 -3 /tmp/c{1,2}.txt
      rm /tmp/{1,2}.txt
    
  * check that all public api is used in tests
    nm --defined-only .libs/libbuzztard-core.a | grep " T " | cut -d' ' -f3 | grep -v "marshal" | sort >/tmp/m1.txt;
    nm --undefined-only .libs/libbtcore-check.a | grep " U bt" | cut -c20- | sort | uniq >/tmp/m2.txt;
    comm -2 -3 /tmp/m{1,2}.txt
    
    grep ");" src/lib/core/core.h | cut -d'(' -f1 | cut -d' ' -f2 | cut -d'*' -f2
    find src/lib/core -name "*.h" -exec grep ");" {} \; | cut -d'(' -f1 | cut -d' ' -f2 | cut -d'*' -f2

  * check that we use loop-tests
    find lib/ -name "*.c" -exec egrep -Hn "(for|while)\s*\(" {} \; | egrep -v "(:\s*\*|://)"


* new stats
  * http://www.chris-lott.org/resources/cmetrics/cyclo-2.0.tar.gz
    mcstrip tools.c | cyclo -c | sort -k2 -n

* quality checks
  for file in src/lib/core/*.c; do gtkdoc-depscan -v --book gstreamer-0.10:0.10.8 $file; done
  
* check translation markup
  podebug --rewrite=xxx buzztard.pot aa.po
  LC_ALL=aa ./buzztard-edit
  - this creates a translation with all strings wrapped by 'xxx' (Help -> xxxHelpxxx)
  - it is easy to see what is not marked for translation  

* sparse
  make CC=cgcc


* controller api
  * allow to modify interpolation control sequence inplace (scale time or value range)
    - we need a gst_interpolation_control_foreach(cs, callback, user_data)
    - the callback will be called for each controlpoint and can change the
      timestamp and/or value
    - need a way to do it without exposing GstControlPoint internals
      - void callback(GstClockTime *timestamp, GValue *value, gpointer user_data);
  * or have a BtPatternControlSource
    - then we never need to update the timeline controller
    - the individual instances should be relative lightweight and use a central
      controller for some global state
      - we want to pre-cache the tracks for each machine to speed up finding the
        patterns that apply at a given time


* OSC support
  * settings
    * the OSC port for listening
    * add song to path (/<song>/...)
  * namespace
    * ../<machine>/set_{wire,global,voice}_param 
    * ../<machine>/set_{mute,solo,bypass}
    * ../<machine>/<pattern>/set_{wire,global,voice}_event
    * ../{play,stop,pause}
  * ui (if osc enabled)
    * show the osc path both in machine and pattern view
    * eventually make it editable (ensure unique)
    * store with song


* undo/redo/journaling
  - links
    http://www.buzztard.org/index.php/Undo,_redo
    http://www.buzztard.org/index.php/Song_autosaving
  - we do that on the ui level (also the journalling and the replay of it)
  - singleton journal object
    - each undo/redo capabale object registeres with its name there
    - on replay we can take the prefix og the entry and dispatch
    - on journalling we can probably add the prefix
    - it is a stack of journal entries
  - pending parts that need undo/redo
    - machine view
      - machine/wire parameters
    - wavetable view
    - info view
  - order of serialisation and destruction
    - see main-page-machines.c:1512
    - use g_signal_connect_after() for the '-removed' handler that are
      destructive (search for '-removed",G_CALLBACK') can help
    - g_object_add_weak_ref is not useful as the object is already gone
    - example: bt_setup_remove_machine
      - what we want:
        machine data {
          track data
          pattern data 0
          ...
          pattern data n
        }
      - what happens:
        emit "removed" signal
          pre:
            main-page-machines:on_machine_removed: beg log undo/redo + machine-data
            main-page-sequence:on_machine_removed: track data + remove track
          default: bt_setup_on_machine_removed ?
            foreach pattern do: bt_machine_remove_pattern
              emit "removed" signal
                pre:
                  main-page-patterns:on_pattern_removed: beg log undo/redo + pattern data
                  main-page-sequence:on_pattern_removed: no track -> skip
                default: bt_machine_on_pattern_removed ?
                  -
                after:
                  end log undo/redo
              remove & unref
          after:
            end log undo/redo
        remove & unref
    - generic phases:
      1) owner:before_xxx_removed: beg log undo/redo + xxx data
      2) others:on_xxx_removed: log other object
      3) children: emit 'removed'
      4) owner: after_xxx_removed: end log undo/redo
      5) remove & unref
    - it is probably easier to have explicit api in the participating UI object
      - we will not rely on the signals
      - before calling xxx_remove on libcore, we will serialize the objects


* Hide libxml2 use behind a PersistenceIO interface in a XMLPersistenceIO
  implementation. The API would also allow to change the implementation to use
  e.g. json or a binary representation instead. We need an API like:
  PersistenceIONode: opaque handle
  // for saving
  PersistenceIONode *bt_persistence_io_new_node(PersistenceIONode *parent, gchar *name);
  gboolean bt_persistence_io_set_value(PersistenceIONode *parent, gchar *value);
  gboolean bt_persistence_io_set_attribute(PersistenceIONode *parent, gchar *name, gchar *value);
  // a varargs function that takes (gchar *name, GType type, <type> value)
  // triplets, terminated by NULL 
  gboolean bt_persistence_io_set_attributes(PersistenceIONode *parent, 
    gchar *name, ...);
  // collection api ...
  gboolean bt_persistence_io_set_attributes_from_hash_table(PersistenceIONode *parent, GHashTable *hash_table);
  
  // for loading
  GList *bt_persistence_io_get_nodes(PersistenceIONode *parent);
  gchar *bt_persistence_io_get_value(PersistenceIONode *parent);
  gchar *bt_persistence_io_get_attribute(PersistenceIONode *parent, gchar *name);
  // a varargs function that takes (gchar *name, GType type, <type *> value)
  // triplets, terminated by NULL 
  gboolean bt_persistence_io_get_attributes(PersistenceIONode *parent, 
    gchar *name, ...);


* CPU load per machine
  - as we alway plug the tee-elements on each machine and each wire starts with
    a queue we could do CPU load per thread
    - sources start their own thread
    - effects and the sink live in the thread of one of the incomming wires
    - build a thread_id<->machine mapping
      - a hackish way would be to run a pad_probe before the machine and
        send a message to the bus with the thread-id<->machine association
      - a better way would be to use gst_message_parse_stream_status
        see src/lib/core/song.c::on_song_request_state()
  - ideally we show it on the machine view
    - extra gnome-canvas-item-rect under machine name?
    - extra dialog from tools menu?
    - enable/disable from the view menu
  - bt-command could have a profile option (for play/encode) and print a summary
    at the end


* Allow disabling level-meters
  - we could iterator over machine, check which levels are activated and
    set the 'message' property true/false
  - this could be api on song/setup
  - the recorder would use it for extra speed
  - on slow platforms we could offer that in the UI (where)
    - the view menu?


* eventually merge machine-rename dialog with machine properties


* improve recording dialogs
  - either integrate the progress bar into the recording settings
    - gray out the dialog or progress-bar area depending on phase
  - or use a notebook with hidden pages
    - switch to 2nd page for rendering


* control machines (no in/out)
  - color=gray
    it is never connected and thus, does not need a desaturated shade
  - scheduling
    - from a property notifies on sink-bin
      - need ts
    - run a GstTask and sync to the clock
      - need to implement tempo iface
      - need to hande seeks (to know direction :/)
  - we can use that for midi-out
    - global params: midi-device (enum)
    - voice params: midi-channel, note, velocity, controller1, control-value1, ... 
  - subclass the control-machines from GstElement
    - no pads (and therefore no _loop() or _chain() function
    - we see them in the registry


* play machines via midi
  - we have machines with one or more note-params
    - sometimes only one is a trigger though
    cd bml/tests/testmachine
    grep -H PT_NOTE *.txt.* | sort | uniq -c | sort -g
  - we have machines with one or more value trigger parames (drum machines)
  - we need to have the idle_loop playing when having keyboard assignments
  - gui workflow:
    - v1: start from the key-controllers
      - a toolbar on the bottom
        - show/hide in the view menu
        - left a combobox to select the device (keyboard, midi, ...)
        - next the piano key graphics
        - next two comboboxes for key assignment and velocity assignment
          - velocity assignment is empty, when selecting machine+key,
            it will show possible velocity targets
          - for drum-machines, we select the parameter with the key and put the
            velecity into the respective parameter
      - mark a key-range, assign to machine/note-param (with key offset)
      - select a key-range, unassign
      - move key-ranges
    - v2: start from pattern column headings
      - have bind/unbind like in machine window
      - define split'ed devices elsewhere
  - how to easily assign a series of key to a series of triggers in one machine
    - have a trigger group  (and assign to white keys only)
    - this would manage both key-number and velocity as we'd only bind a series
      of abs-value-controls (velocity) to the drum-machine triggers
  - how to assign velocity to the machines velocity param
  - the current code in machine.c (_poly_control_) would increment the voice on
    each control event, we would need to set both key and velocity though
    we also need to ensure to set velocity first and then the key
    - only inc the voice-counter on the trigger param?


* text parameters in machines
  * for a:
    * text to speech machine we'd like to have strings in the pattern
    * cmd-out machine we'd like to send a dbus command, run a script etc.
  * like we have a wavetable, we could have a text table
    * a list of text snipped (more than 256!)
    * each snippet has a label and a text block (multiline)
  * in a text to speech machine we can use text-table index (gint 16 bit),
    text offset (gint 16 bit char offset), length (unset, to the end) and
    direction (forward, backward)
  * in a command out machine, we use the text table index (gint 16 bit) and
    ev. script parameters (passed as $1, $2, ...)


* wave table, record entries
  * we can just keep the buffers from fakesink/appsink in a list and consolidate
    on eos
  * need device selection on the source


* one framerate for animations
  * we have a couple of things that we update in intervals:
    * 10fps: main-page-waves.c: preview_update_id=g_timeout_add_full(G_PRIORITY_HIGH,1000/10,on_preview_playback_update,(gpointer)self,NULL);
    * 10fps: main-toolbar.c: playback_update_id=g_timeout_add_full(G_PRIORITY_HIGH,1000/10,on_song_playback_update,(gpointer)song,NULL);
    * 10fps: machine.c: g_object_set(PART_*LEVEL,"interval",(GstClockTime)(0.1*GST_SECOND),...
    * 10fps: signal-analysis-dialog: g_object_set(ANALYZER_*, "interval",(GstClockTime)(0.1*GST_SECOND),...
  * we should have one #define somewhere for the UPDATE_INTERVAL
  * ideally we ensure that the framerate is an integer multiple of it
  * it would be nice to avoid a setting, but for slow machines it might be worth it
    (or for fast machine, people could pick a higher rate)
  * we could use configure and have the define in config.h


* pattern and main-page-patterns still contain bits of duplicated code
  * review the pattern api and check if we should use the groups directly
    (run ./api-cleanup.sh to get a report of where the api is used)


* sparse enums
  * we need to avoid them, they cause troubles
    * with backwards compatibility (we could handle that in the loader)
    * with stepwise data entry
  * we need to use them, the allow
    * useful randomize/blend
  1) we could use a gint for enum parameters in value-groups and translate them
    to the machine parameters, filtering out invalid ones
    * param-group could expose enums as int
      * no changes in value-group
      * but probably breakage in the machine UI
    * value-group maps enum to int (keeping the range)
      * needs changes in bt_parameter_group_controller_change_value() or
        bt_sequence_repair_damage_entries() to map  them back
      * bt_value_group_blend/randomize would still need to check the enum to
        handle sparse operations
  2) we could have extra columns in the pattern for each enum column
    * these columns would have an int type
    * bt_value_group_set_event() would set the int and the real column if the
      value is valid
    * bt_value_group_get_event() would get the real column or the int value if
      real is not valid
    * bt_value_group_get_event_data() would get the real column value pointer
    * invalid values are treated like empty cells
    * need to change bt_value_group_resize_data_length() and
      bt_value_group_finalize() for the data alloc/free
    * Questions:
      * should blend consider the closest valid value?
      * do we want API to tell wheter a value is valid
        * the pattern editor could use the that shade the color of invalid cells
      * do we also copy shadow data?
        * when copying patterns or doing copy/paste operations
      * do we need this for other types? 
        pattern-editor does already min/max clamping
     
    


* generate a dependency matrix
  * 'make ctags' creates tags files per directory containing symbol locations
  * 'ctags -x --recurse src tests >xref' creates a single xref table containing
    all symbol locations
  * 'find . -name "*.o" -exec nm --undefined-only {} \; | grep " bt_"'
    creates a list of externally called entries
  
